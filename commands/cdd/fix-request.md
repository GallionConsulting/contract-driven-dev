---
name: cdd:fix-request
description: Triage issues into per-module fix files for focused processing
allowed-tools:
  - Read
  - Write
  - Glob
---

<objective>
Parse chatty issue input (from audit findings, code reviews, or manual inspection) into structured YAML fix files grouped by module. This is the lightweight triage step — no code reading, no fixes, no context pressure. Each fix file feeds into a separate `/cdd:fix` session for focused per-module surgery.
</objective>

<execution_context>
You are running the `cdd:fix-request` command. This is a LIGHTWEIGHT TRIAGE command that writes structured fix files.

**Argument:** The user MUST provide a list of issues. Accepted formats:
- Markdown table with columns for module, issue description, severity, and/or category
- Numbered list (e.g., `1. module-name: description`)
- Bullet list (e.g., `- module-name: description`)
- Plain text paragraphs describing issues (will be parsed best-effort)

If no issues are provided, display usage instructions and stop.

**Pre-conditions — check these FIRST:**
1. Read `.cdd/state.yaml`
2. Verify `phase` is `build_cycle` or `complete` — if in `planning` or `foundation`, tell the user that fixes require at least one completed module. Stop.
3. Verify at least ONE module has `status: complete` — if no modules are complete, tell the user to complete a module first with `/cdd:build`. Stop.

**Context loaded (LIGHTWEIGHT):**
- `.cdd/state.yaml` — for module names, statuses, and build_order
- `.cdd/config.yaml` — for project name only

**Context NOT loaded:**
- Module contracts
- Source code files
- Data contracts
- System invariants
</execution_context>

<process>

## Step 1: Check Pre-conditions

Read `.cdd/state.yaml` and `.cdd/config.yaml`. Verify:
- `phase` is `build_cycle` or `complete`
- At least one module has `status: complete`

If pre-conditions fail, explain why and suggest the correct next command. Stop.

## Step 2: Parse Issues

Parse the user-provided issue list into structured entries. Extract for each issue:
- **Module name** — which module is affected
- **Description** — what the issue is
- **Severity** — critical / high / medium / low (default to `medium` if not specified)
- **Category** — bug / performance / security / contract / style / portability (default to `bug` if not specified)

Assign sequential IDs: `FIX-1`, `FIX-2`, `FIX-3`, etc.

**Module resolution:**
- Match module names against modules listed in `state.yaml`
- Accept partial matches, case-insensitive (e.g., "grid" matches "grid-ui")
- If a module name cannot be resolved, collect it as an unresolved issue

**If ANY issues have unresolved modules**, display them and stop:
```
CDD:FIX-REQUEST — UNRESOLVED MODULES

The following issues reference modules that don't exist in state.yaml:

  FIX-[N]: "[description]" — module "[name]" not found

Available modules:
  - [list of modules from state.yaml]

Please correct the module names and re-run /cdd:fix-request.
```

## Step 3: Handle Cross-Module Issues

If an issue spans multiple modules (e.g., "inconsistent response building in Auth and Team Membership"):
- Split into separate issues per module: FIX-9a (auth), FIX-9b (team-membership)
- Each gets the same description with a note that it's part of a cross-module fix

## Step 4: Handle System-Level Issues

Issues targeting "system-level" or referencing system invariants/config (not a specific module):
- Route to the most relevant module based on the issue description
- Or flag as `CONTRACT_ISSUE` category if it's purely a contract/invariant labeling problem

## Step 5: Filter by Module Completion Status

Check each resolved module's `status` in `state.yaml`:
- **`status: complete`** — generate a fix file for this module (proceed to Step 6)
- **Any other status** — do NOT generate a fix file. Collect these issues as deferred.

This prevents generating fix files that `/cdd:fix` would reject (fix requires `status: complete`).

## Step 6: Group by Module and Generate Fix Files

Generate a timestamp for the batch: `FIX-YYYYMMDD-HHMM` (e.g., `FIX-20260215-1030`).

Ensure directories exist: `.cdd/fixes/pending/` (create if needed).

Generate one YAML file per **complete** module at `.cdd/fixes/pending/[module]-FIX-[timestamp].yaml`:

```yaml
# Fix batch for [module]
# Generated by /cdd:fix-request

batch_id: "FIX-20260215-1030"
module: task-management
generated_at: "2026-02-15T10:30:00Z"
status: pending

issues:
  - id: FIX-2
    severity: medium
    category: contract
    description: "DG-10 query param mismatch (status vs include_archived)"

  - id: FIX-3
    severity: low
    category: contract
    description: "tasks table ownership miscategorized"
```

Issues within each file are ordered by severity: critical > high > medium > low.

## Step 7: Display Run Sheet

```
CDD:FIX-REQUEST — [N] issues triaged into [M] fix batches

Fix files created:

  .cdd/fixes/pending/auth-FIX-20260215-1030.yaml           ([N] issues)
  .cdd/fixes/pending/task-management-FIX-20260215-1030.yaml ([N] issues)

[If any issues were deferred due to module not complete:]
DEFERRED — module not complete
  FIX-[N]: [module] ([status]) — [description]
  FIX-[N]: [module] ([status]) — [description]

  These issues cannot be fixed until their modules are complete.
  Complete the modules first, then re-run /cdd:fix-request.

RUN SHEET — execute in order, /clear between each command

  /clear
  /cdd:fix auth-FIX-20260215-1030
  /clear
  /cdd:verify auth
  /clear
  /cdd:test auth
  /clear
  /cdd:fix task-management-FIX-20260215-1030
  /clear
  /cdd:verify task-management
  /clear
  /cdd:test task-management

Total: [M] fix sessions + [M] verify sessions + [M] test sessions
Module order follows build_order from state.yaml.
```

</process>
</output>
